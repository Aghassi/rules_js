package gazelle

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/bazel-gazelle/config"
	"github.com/bazelbuild/bazel-gazelle/label"
	"github.com/bazelbuild/bazel-gazelle/repo"
	"github.com/bazelbuild/bazel-gazelle/resolve"
	"github.com/bazelbuild/bazel-gazelle/rule"
	bzl "github.com/bazelbuild/buildtools/build"
	"github.com/emirpasic/gods/sets/treeset"
	godsutils "github.com/emirpasic/gods/utils"

	"aspect.build/rules_js/gazelle/tsconfig"
)

const languageName = "ts"

const (
	// resolvedDepsKey is the attribute key used to pass dependencies that don't
	// need to be resolved by the dependency resolver in the Resolver step.
	resolvedDepsKey = "_gazelle_ts_resolved_deps"
)

// Resolver satisfies the resolve.Resolver interface. It resolves dependencies
// in rules generated by this extension.
type Resolver struct{}

// Name returns the name of the language. This is the prefix of the kinds of
// rules generated. E.g. ts_project
func (*Resolver) Name() string { return languageName }

// Imports returns a list of ImportSpecs that can be used to import the rule
// r. This is used to populate RuleIndex.
//
// If nil is returned, the rule will not be indexed. If any non-nil slice is
// returned, including an empty slice, the rule will be indexed.
func (ts *Resolver) Imports(c *config.Config, r *rule.Rule, f *rule.File) []resolve.ImportSpec {
	srcs := r.AttrStrings("srcs")
	provides := make([]resolve.ImportSpec, 0, len(srcs)+1)
	for _, src := range srcs {
		ext := filepath.Ext(src)
		// TODO: json? js? etc?
		if ext == ".ts" {
			provide := importSpecFromSrc(f.Pkg, src)
			provides = append(provides, provide)
		}
	}
	if len(provides) == 0 {
		return nil
	}
	return provides
}

// importSpecFromSrc determines the ImportSpec based on the target that contains the src so that
// the target can be indexed for import statements that match the calculated src relative to the its
// TypeScript project root.
func importSpecFromSrc(bzlPkg, src string) resolve.ImportSpec {
	tsPkgDir := filepath.Join(bzlPkg, filepath.Dir(src))
	relTypeScriptPkgDir, err := filepath.Rel("", tsPkgDir)
	if err != nil {
		panic(fmt.Errorf("unexpected failure: %v", err))
	}
	if relTypeScriptPkgDir == "." {
		relTypeScriptPkgDir = ""
	}
	// TODO: how does import statements look like in ts?
	tsPkg := strings.ReplaceAll(relTypeScriptPkgDir, "/", ".")
	filename := filepath.Base(src)
	// TODO?
	// if filename == tsLibraryEntrypointFilename {
	// 	if tsPkg != "" {
	// 		return resolve.ImportSpec{
	// 			Lang: languageName,
	// 			Imp:  tsPkg,
	// 		}
	// 	}
	// }
	moduleName := strings.TrimSuffix(filename, ".ts")
	var imp string
	if tsPkg == "" {
		imp = moduleName
	} else {
		imp = fmt.Sprintf("%s.%s", tsPkg, moduleName)
	}
	return resolve.ImportSpec{
		Lang: languageName,
		Imp:  imp,
	}
}

// Embeds returns a list of labels of rules that the given rule embeds. If
// a rule is embedded by another importable rule of the same language, only
// the embedding rule will be indexed. The embedding rule will inherit
// the imports of the embedded rule.
func (ts *Resolver) Embeds(r *rule.Rule, from label.Label) []label.Label {
	// TODO(f0rmiga): implement.
	return make([]label.Label, 0)
}

// Resolve translates imported libraries for a given rule into Bazel
// dependencies. Information about imported libraries is returned for each
// rule generated by language.GenerateRules in
// language.GenerateResult.Imports. Resolve generates a "deps" attribute (or
// the appropriate language-specific equivalent) for each import according to
// language-specific rules and heuristics.
func (ts *Resolver) Resolve(
	c *config.Config,
	ix *resolve.RuleIndex,
	rc *repo.RemoteCache,
	r *rule.Rule,
	modulesRaw interface{},
	from label.Label,
) {
	deps := treeset.NewWith(godsutils.StringComparator)

	// Pre-resolved deps
	resolvedDepsIt := r.PrivateAttr(resolvedDepsKey).(*treeset.Set).Iterator()
	for resolvedDepsIt.Next() {
		deps.Add(resolvedDepsIt.Value())
	}

	if modulesRaw != nil {
		ResolveModuleDeps(c, ix, modulesRaw.(*treeset.Set), from, deps)
	}

	if !deps.Empty() {
		r.SetAttr("deps", convertDependencySetToExpr(deps))
	}
}

func ResolveModuleDeps(
	c *config.Config,
	ix *resolve.RuleIndex,
	modules *treeset.Set,
	from label.Label,
	deps *treeset.Set,
) {
	cfgs := c.Exts[languageName].(tsconfig.Configs)
	cfg := cfgs[from.Pkg]
	it := modules.Iterator()
	explainDependency := os.Getenv("EXPLAIN_DEPENDENCY")
	hasFatalError := false
MODULE_LOOP:
	for it.Next() {
		mod := it.Value().(module)
		imp := resolve.ImportSpec{Lang: languageName, Imp: mod.Name}
		if override, ok := resolve.FindRuleWithOverride(c, imp, languageName); ok {
			if override.Repo == "" {
				override.Repo = from.Repo
			}
			if !override.Equal(from) {
				if override.Repo == from.Repo {
					override.Repo = ""
				}
				dep := override.String()
				deps.Add(dep)
				if explainDependency == dep {
					log.Printf("Explaining dependency (%s): "+
						"in the target %q, the file %q imports %q at line %d, "+
						"which resolves using the \"gazelle:resolve\" directive.\n",
						explainDependency, from.String(), mod.Filepath, mod.Name, mod.LineNumber)
				}
			}
		} else if dep, ok := cfg.FindThirdPartyDependency(mod.Name); ok {
			deps.Add(dep)
			if explainDependency == dep {
				log.Printf("Explaining dependency (%s): "+
					"in the target %q, the file %q imports %q at line %d, "+
					"which resolves from the third-party module %q from the wheel %q.\n",
					explainDependency, from.String(), mod.Filepath, mod.Name, mod.LineNumber, mod.Name, dep)
			}
		} else if matches := ix.FindRulesByImportWithConfig(c, imp, languageName); len(matches) > 0 {
			filteredMatches := make([]resolve.FindResult, 0, len(matches))
			for _, match := range matches {
				if match.IsSelfImport(from) {
					// Prevent from adding itself as a dependency.
					continue MODULE_LOOP
				}
				filteredMatches = append(filteredMatches, match)
			}
			if len(filteredMatches) > 1 {
				// TODO(jbedard): this loop is now unnecessary?
				sameRootMatches := make([]resolve.FindResult, 0, len(filteredMatches))
				for _, match := range filteredMatches {
					sameRootMatches = append(sameRootMatches, match)
				}
				if len(sameRootMatches) != 1 {
					err := fmt.Errorf(
						"multiple targets (%s) may be imported with %q at line %d in %q "+
							"- this must be fixed using the \"gazelle:resolve\" directive",
						targetListFromResults(filteredMatches), mod.Name, mod.LineNumber, mod.Filepath)
					log.Println("ERROR: ", err)
					hasFatalError = true
					continue MODULE_LOOP
				}
				filteredMatches = sameRootMatches
				matchLabel := filteredMatches[0].Label.Rel(from.Repo, from.Pkg)
				dep := matchLabel.String()
				deps.Add(dep)
				if explainDependency == dep {
					log.Printf("Explaining dependency (%s): "+
						"in the target %q, the file %q imports %q at line %d, "+
						"which resolves from the first-party indexed labels.\n",
						explainDependency, from.String(), mod.Filepath, mod.Name, mod.LineNumber)
				}
			}
		} else if cfg.ValidateImportStatements() {
			err := fmt.Errorf(
				"%[1]q at line %[2]d from %[3]q is an invalid dependency: possible solutions:\n"+
					"\t1. Add it as a dependency in the requirements.txt file.\n"+
					"\t2. Instruct Gazelle to resolve to a known dependency using the gazelle:resolve directive.\n"+
					"\t3. Ignore it with a comment '# gazelle:ignore %[1]s' in the TypeScript file.\n",
				mod.Name, mod.LineNumber, mod.Filepath,
			)
			log.Printf("ERROR: failed to validate dependencies for target %q: %v\n", from.String(), err)
			hasFatalError = true
			continue MODULE_LOOP
		}
	}
	if hasFatalError {
		os.Exit(1)
	}
}

// targetListFromResults returns a string with the human-readable list of
// targets contained in the given results.
func targetListFromResults(results []resolve.FindResult) string {
	list := make([]string, len(results))
	for i, result := range results {
		list[i] = result.Label.String()
	}
	return strings.Join(list, ", ")
}

// convertDependencySetToExpr converts the given set of dependencies to an
// expression to be used in the deps attribute.
func convertDependencySetToExpr(set *treeset.Set) bzl.Expr {
	deps := make([]bzl.Expr, set.Size())
	it := set.Iterator()
	for it.Next() {
		dep := it.Value().(string)
		deps[it.Index()] = &bzl.StringExpr{Value: dep}
	}
	return &bzl.ListExpr{List: deps}
}
